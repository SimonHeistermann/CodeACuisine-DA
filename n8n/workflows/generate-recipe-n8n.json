{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-recipe",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -1520,
        16
      ],
      "id": "100272c3-c546-4271-a85f-323c1e2b36d8",
      "name": "Webhook",
      "webhookId": "584d5e6b-0e54-4d64-9df6-5212b4d9c912"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are part of a workflow of an application that lets users enter the ingredients they have at home and select some preferences. Your task is to generate cooking recipes strictly in JSON format.\n\nYour task:\n\nReceive all ingredients and preferences from the input JSON.\n\nGenerate exactly three recipes based on this data.\n\nRecipes should primarily use the provided ingredients, but you may add extra ingredients to improve taste or structure.\n\nSeparate ingredients the user already has from additional ones you introduce.\n\nOutput format:\nReturn a JSON array of exactly 3 recipe objects. No prose, no explanations, only JSON.\n\nEach recipe object must contain these keys:\n\n\"title\": string – the name of the recipe\n\n\"cookingTimeText\": string – time to prepare this recipe (e.g. \"45 minutes\")\n\n\"cookingTimeMinutes\": number – integer minutes (e.g. 45). If you only know the text, derive the minutes from it.\n\n\"nutritionalInformation\": object with keys { \"calories\", \"proteins\", \"fats\", \"carbs\" } (numbers)\n\n\"preferences\": object with the keys { \"cookingTime\", \"cuisine\", \"dietPreferences\" }\nIMPORTANT: These values MUST be strings and MUST match the user input when available. If missing in your own reasoning, copy them from the user input.\n\n\"cooksAmount\": number – amount of cooks (same as input)\n\n\"ingredients\": object with two keys:\n\n\"yourIngredients\": array of ingredient objects\n\n\"extraIngredients\": array of ingredient objects you add\nEach ingredient object must have keys { \"ingredient\", \"servingSize\", \"unit\" } where \"unit\" is an object like { \"name\", \"abbreviation\" }.\n\n\"directions\": array of step objects, each with keys:\n\n\"order\": number (1-based)\n\n\"title\": short string title of the step\n\n\"description\": detailed string description of the step\n\n\"cook\": number indicating which cook (1..cooksAmount) should do this step\n\nIMPORTANT RULES:\n\nReturn valid JSON only. No markdown, no comments, no trailing commas.\n\nReturn exactly three recipes in one top-level JSON array.\n\nDo not include any additional fields or text outside this structure.\n\nNEVER output undefined or null for required string fields. Always output a string (use \"\" only if absolutely necessary).\n\nUser data (already validated and normalized):\n\n{{ JSON.stringify($node[\"Validate & Normalize Input\"].json.request) }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        272,
        112
      ],
      "id": "43049529-82c9-4452-95ec-c76e1e3c0c1a",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "jsCode": "let raw = $json.output ?? $json.result ?? $json;\n\nconst toText = (v) => {\n  if (Array.isArray(v)) return String(v[0] ?? '').trim();\n  if (v == null) return '';\n  return String(v).trim();\n};\n\nif (typeof raw === 'string') {\n  let text = raw.trim();\n\n  if (text.startsWith('```')) {\n    const firstNewline = text.indexOf('\\n');\n    if (firstNewline !== -1) {\n      text = text.slice(firstNewline + 1);\n    }\n\n    const fenceIndex = text.lastIndexOf('```');\n    if (fenceIndex !== -1) {\n      text = text.slice(0, fenceIndex);\n    }\n  }\n\n  text = text.trim();\n\n  try {\n    raw = JSON.parse(text);\n  } catch (e) {\n    throw new Error('LLM did not return valid JSON: ' + e.message);\n  }\n}\n\nif (!Array.isArray(raw)) {\n  throw new Error('Expected an array of recipes from LLM');\n}\n\nif (raw.length > 3) {\n  raw = raw.slice(0, 3);\n}\n\nconst toNumber = (value, fallback = 0) => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') {\n    const match = value.match(/-?\\d+(\\.\\d+)?/);\n    return match ? parseFloat(match[0]) : fallback;\n  }\n  return fallback;\n};\n\nconst toInt = (value, fallback = 0) => {\n  const n = toNumber(value, fallback);\n  return Number.isFinite(n) ? Math.trunc(n) : fallback;\n};\n\nconst clampInt = (n, min, max) => Math.max(min, Math.min(max, n));\n\nconst ensureUnit = (unit) => {\n  if (\n    unit &&\n    typeof unit === 'object' &&\n    typeof unit.name === 'string' &&\n    typeof unit.abbreviation === 'string'\n  ) {\n    return unit;\n  }\n\n  return {\n    name: 'piece',\n    abbreviation: '',\n  };\n};\n\nconst normalizeIngredient = (ing) => {\n  if (!ing) return null;\n\n  return {\n    ingredient: String(ing.ingredient ?? ''),\n    servingSize: toNumber(ing.servingSize ?? 0),\n    unit: ensureUnit(ing.unit),\n  };\n};\n\nconst normalized = raw.map((recipe, recipeIndex) => {\n  const ni = recipe.nutritionalInformation ?? {};\n  const prefs = recipe.preferences ?? {};\n  const ingredients = recipe.ingredients ?? {};\n  const your = Array.isArray(ingredients.yourIngredients)\n    ? ingredients.yourIngredients\n    : [];\n  const extra = Array.isArray(ingredients.extraIngredients)\n    ? ingredients.extraIngredients\n    : [];\n\n  const cooksAmount = Math.max(1, toInt(recipe.cooksAmount ?? 1, 1));\n  const cookingTimeText = String(recipe.cookingTimeText ?? recipe.cookingTime ?? '').trim();\n\n  const cookingTimeMinutes =\n    recipe.cookingTimeMinutes == null\n      ? null\n      : toInt(recipe.cookingTimeMinutes, 0);\n\n  return {\n    json: {\n      title: String(recipe.title ?? `Recipe ${recipeIndex + 1}`),\n      cookingTimeText,\n      cookingTimeMinutes,\n\n      cooksAmount,\n\n      nutritionalInformation: {\n        calories: toNumber(ni.calories ?? 0, 0),\n        proteins: toNumber(ni.proteins ?? 0, 0),\n        fats: toNumber(ni.fats ?? 0, 0),\n        carbs: toNumber(ni.carbs ?? 0, 0),\n      },\n\n      preferences: {\n        cookingTime: toText($('Validate & Normalize Input').first().json.request.cookingTime) || '',\n        cuisine: toText($('Validate & Normalize Input').first().json.request.cuisine) || '',\n        dietPreferences: toText($('Validate & Normalize Input').first().json.request.dietPreferences) || '',\n      },\n\n      ingredients: {\n        yourIngredients: your\n          .map(normalizeIngredient)\n          .filter((x) => x !== null),\n        extraIngredients: extra\n          .map(normalizeIngredient)\n          .filter((x) => x !== null),\n      },\n\n      directions: Array.isArray(recipe.directions)\n        ? recipe.directions.map((step, i) => ({\n            order: toInt(step.order ?? i + 1, i + 1),\n            title: String(step.title ?? `Step ${i + 1}`),\n            description: String(step.description ?? ''),\n            cook: clampInt(toInt(step.cook ?? 1, 1), 1, cooksAmount),\n          }))\n        : [],\n    },\n  };\n});\n\nreturn normalized;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        112
      ],
      "id": "88a7e55d-0182-4a67-83b3-c69523289094",
      "name": "Normalize & Validate Recipes"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        1072,
        112
      ],
      "id": "026049b9-1ce5-459f-bb12-07e70f85573b",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        336,
        336
      ],
      "id": "ef95b278-cf43-41b7-838b-bb1e6765a933",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "2AVsosIQMcC3gtrV",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const headers = $json.headers || {};\nconst request = $json.request || {};\n\nlet ip =\n  headers['x-forwarded-for'] ||\n  headers['X-Forwarded-For'] ||\n  headers['x-real-ip'] ||\n  headers['X-Real-IP'] ||\n  request.ip ||\n  $json.ip ||\n  'unknown';\n\nip = String(ip).split(',')[0].trim().toLowerCase();\n\nconst now = new Date();\nconst day = now.toISOString().slice(0, 10);\nconst minute = now.toISOString().slice(0, 16).replace(/[:T]/g, '-');\n\nreturn [{\n  json: {\n    headers,\n    request,  \n    ip,\n    day,\n    keys: {\n      ipQuota: `quota:ip:${ip}:${day}`,\n      systemQuota: `quota:system:${day}`,\n      rateMinute: `rate:ip:${ip}:${minute}`,\n    },\n    limits: {\n      ipPerDay: 3,\n      systemPerDay: 12,\n      ratePerMinute: 5,\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1072,
        16
      ],
      "id": "b1437fc9-ccf4-4c7e-9e50-c6ec66badf82",
      "name": "Extract & Normalize Client IP (IPv4/IPv6)"
    },
    {
      "parameters": {
        "operation": "incr",
        "key": "={{$node[\"Extract & Normalize Client IP (IPv4/IPv6)\"].json.keys.ipQuota}}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -848,
        16
      ],
      "id": "1da301cb-fbcf-4d4e-af4c-708a8aa39b2f",
      "name": "Redis INCR – IP Quota (daily)",
      "credentials": {
        "redis": {
          "id": "VIL9dzixG8dimu32",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "incr",
        "key": "={{$node[\"Extract & Normalize Client IP (IPv4/IPv6)\"].json.keys.systemQuota}}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -624,
        16
      ],
      "id": "ce787d5c-a1cf-469f-b1f6-9888a055b304",
      "name": "Redis INCR – System Quota (daily)",
      "credentials": {
        "redis": {
          "id": "VIL9dzixG8dimu32",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "incr",
        "key": "={{$node[\"Extract & Normalize Client IP (IPv4/IPv6)\"].json.keys.rateMinute}}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -400,
        16
      ],
      "id": "f97d3d45-4656-40fd-be2f-3ac65a7d3b43",
      "name": "Redis INCR – Rate Limit (per minute)",
      "credentials": {
        "redis": {
          "id": "VIL9dzixG8dimu32",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "ea967dfa-42d4-4038-be08-c2ff081a1fe1",
              "leftValue": "={{$node[\"Redis INCR – IP Quota (daily)\"].json.value}}",
              "rightValue": 3,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            },
            {
              "id": "72365998-f326-45a4-90fe-4ce28975dc02",
              "leftValue": "={{$node[\"Redis INCR – System Quota (daily)\"].json.value}}",
              "rightValue": 12,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            },
            {
              "id": "30d3be2a-9a58-4040-96f5-31fa84197bf6",
              "leftValue": "={{$node[\"Redis INCR – Rate Limit (per minute)\"].json.value}}",
              "rightValue": 5,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "or"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -176,
        16
      ],
      "id": "ac6275fd-0eef-492b-8843-a2f8896d8495",
      "name": "If"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"error\": \"quota_exceeded\",\n  \"message\": \"Du hast dein Tageslimit erreicht oder zu viele Anfragen in kurzer Zeit gesendet.\",\n  \"quota\": {\n    \"ip\": {\n      \"limit\": 3,\n      \"used\": \"={{$node['Redis INCR – IP Quota (daily)'].json.value}}\",\n      \"remaining\": \"={{Math.max(0, 3 - $node['Redis INCR – IP Quota (daily)'].json.value)}}\"\n    },\n    \"system\": {\n      \"limit\": 12,\n      \"used\": \"={{$node['Redis INCR – System Quota (daily)'].json.value}}\",\n      \"remaining\": \"={{Math.max(0, 12 - $node['Redis INCR – System Quota (daily)'].json.value)}}\"\n    }\n  }\n}",
        "options": {
          "responseCode": 429
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        48,
        -80
      ],
      "id": "1dd27194-b183-4e3d-b5f4-93f77efc3e67",
      "name": "Respond 429 – Quota/Rate exceeded"
    },
    {
      "parameters": {
        "jsCode": "const recipes = $input.all().map(i => i.json);\n\nconst asInt = (v) => {\n  const n = Number(v);\n  return Number.isFinite(n) ? n : 0;\n};\n\nconst ipUsed = asInt($node[\"Redis INCR – IP Quota (daily)\"].json.value);\nconst sysUsed = asInt($node[\"Redis INCR – System Quota (daily)\"].json.value);\n\nreturn [{\n  json: {\n    recipes,\n    quota: {\n      ip: { limit: 3, used: ipUsed, remaining: Math.max(0, 3 - ipUsed) },\n      system: { limit: 12, used: sysUsed, remaining: Math.max(0, 12 - sysUsed) }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        112
      ],
      "id": "e0de5966-8c72-4d7b-b800-6fa0a8475758",
      "name": "Build Success Response (recipes + quota)"
    },
    {
      "parameters": {
        "jsCode": "const headers = $json.headers || {};\nconst body = $json.body || $json;\n\nif (!body.ingredients || !Array.isArray(body.ingredients) || body.ingredients.length === 0) {\n  throw new Error('No ingredients provided in request body.');\n}\n\nconst cleaned = {\n  ...body,\n  ingredients: body.ingredients.map((ing) => {\n    const { isEditMode, isUnitDropdownOpen, ...rest } = ing;\n    return rest;\n  }),\n};\n\nif (cleaned.cookingTime) cleaned.cookingTime = String(cleaned.cookingTime).toLowerCase();\nif (cleaned.cuisine) cleaned.cuisine = String(cleaned.cuisine).toLowerCase();\nif (cleaned.dietPreferences) cleaned.dietPreferences = String(cleaned.dietPreferences).toLowerCase();\n\nif (typeof cleaned.portionsAmount !== 'number' || cleaned.portionsAmount <= 0) cleaned.portionsAmount = 2;\nif (typeof cleaned.cooksAmount !== 'number' || cleaned.cooksAmount <= 0) cleaned.cooksAmount = 1;\n\nreturn [{\n  json: {\n    headers,\n    request: cleaned,\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1296,
        16
      ],
      "id": "59e21cde-48d4-4ab1-b7fc-e6895033fc9b",
      "name": "Validate & Normalize Input"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Validate & Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Normalize & Validate Recipes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize & Validate Recipes": {
      "main": [
        [
          {
            "node": "Build Success Response (recipes + quota)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract & Normalize Client IP (IPv4/IPv6)": {
      "main": [
        [
          {
            "node": "Redis INCR – IP Quota (daily)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis INCR – IP Quota (daily)": {
      "main": [
        [
          {
            "node": "Redis INCR – System Quota (daily)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis INCR – System Quota (daily)": {
      "main": [
        [
          {
            "node": "Redis INCR – Rate Limit (per minute)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis INCR – Rate Limit (per minute)": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Respond 429 – Quota/Rate exceeded",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Success Response (recipes + quota)": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Normalize Input": {
      "main": [
        [
          {
            "node": "Extract & Normalize Client IP (IPv4/IPv6)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "90513134489b0c5692dc97922cf8488b6f51bcfa91783d5bc70f0252b2ac81cc"
  }
}